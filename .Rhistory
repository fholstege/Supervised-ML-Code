r_dsmle$const
View(Airline)
v_1 =  matrix(1, 1, 90)
t(v_1)
v_1 %*% t(v_1)
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- (1/n) * (v_1 %*% t(v_1))
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% (J %*% mY)
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((yhat - mY)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
r_ours = kernel_ridge(mX_scaled, mY, 1000)
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- (1/n) %*% (v_1 %*% t(v_1))
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% (J %*% mY)
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((yhat - mY)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
r_ours = kernel_ridge(mX_scaled, mY, 1000)
diag(n)- (1/n) %*% v_1 %*% t(v_1)
diag(n)- ((1/n) %*% v_1 %*% t(v_1))
diag(n)- (1/n) %*%
v_1 %*% t(v_1)
v_1 %*% t(v_1)
(1/n)*  v_1 %*% t(v_1)
diag(n)- ((1/n)*  v_1 %*% t(v_1))[[1]]
(1/n)*  v_1 %*% t(v_1)
(1/n)*  v_1 %*% t(v_1)[[1]]
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  v_1 %*% t(v_1))[[1]]
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% (J %*% mY)
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((yhat - mY)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
r_ours = kernel_ridge(mX_scaled, mY, 1000)
r_ours$Beta
r_ours$SSE
t(v_1)
optimal_mBeta_zero = (1/n) * t(v_1) %*% mY
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_mBeta_zero
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  v_1 %*% t(v_1))[[1]]
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% (J %*% mY)
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((yhat - mY)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
r_dsmle = dsmle_result = krr(mY, mX, kernel.type = "linear", lambda =1000)
r_dsmle$const
sum((r_dsmle$y - r_dsmle$yhat)^2)
r_ours = kernel_ridge(mX_scaled, mY, 1000)
r_ours$Beta
r_ours$SSE
diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% (J %*% mY)
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((yhat - mY)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
r_ours = kernel_ridge(mX_scaled, mY, 1000)
r_ours$Beta
r_ours$SSE
cbind(1,mX)
r_ours$Beta
r_dsmle$y - r_dsmle$yhat
sum(r_dsmle$y - r_dsmle$yhat)^2
sum(r_dsmle$y - r_dsmle$yhat)^2
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% (J %*% mY)
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((mY - yhat)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
sum(r_dsmle$y - r_dsmle$yhat)^2
r_ours = kernel_ridge(mX_scaled, mY, 1000)
r_ours$Beta
r_ours$SSE
sum((r_dsmle$y - r_dsmle$yhat)^2)
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% (J %*% mY)
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((mY - yhat)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
r_ours = kernel_ridge(mX_scaled, mY, 1000)
r_ours$Beta
r_ours$SSE
r_ours$yhat - r_dsmle$yhat
inv(mX) %*% r_dsmle$yhat
mXXt = mX %*% t(mX)
inv(mXXt)
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * inv(mXXt))) %*% (J %*% mY)
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((mY - yhat)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
r_ours = kernel_ridge(mX_scaled, mY, 1000)
r_ours$Beta
r_ours$SSE
inv(diag(n) + (lambda * inv(mXXt)))
inv(diag(n) + (1000 * inv(mXXt)))
inv(mXtX)
mXXt = mX_scaled %*% t(mX_scaled)
inv(mXXt)
mXXt
scale(mXXt)
mXXt = mX %*% t(mX)
scale(mXXt)
mXXt
mXXt = mX_scaled %*% t(mX_scaled)
mXXt
r = inv(diag(n) + (1000 * inv(mXXt)))
inv(mXXt)
Ginv(mXXt)
r_dsmle$K
inv(r_dsmle$K)
Ginv(r_dsmle$K)
Ginv(mXXt)
svd(MX)
svd(mX)
svd(mXXT)
svd(mXXt)
svd_mXXt <- svd(mXXt)
D <- svd_mXXt$d
U <- svd_mXXt$u
U %*% D^2 %*% t(U)
U %*% D^2
t(U)
U %*% D
U %*% D %*% t(U)
U %*% D * t(U)
D
D^2
U
U
U
dim(U)
dim(D)
dim(as.matrix(D))
D %*% t(D)
U %*% (D %*% t(D)) %*% t(U)
mXXt
svd_mXXt <- svd(mXXt)
mXXt
D <- svd_mXXt$d
U <- svd_mXXt$u
U
view(U)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
J
r_ours = kernel_ridge(mX_scaled, mY, 1000)
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
n = nrow(mX)
p = ncol(mX)
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
optimal_mBeta_zero = (1/n) * v_1 %*% mY
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% J %*% mY
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((mY - yhat)^2)
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
r_ours = kernel_ridge(mX_scaled, mY, 1000)
r_ours$Beta
r_ours$SSE
Ginv(r_dsmle$K)
inv(r_dsmle$K)
mXXt = r_dsmle$K %*% t(r_dsmle$K)
optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% J %*% mY
optimal_q_hat = inv(diag(n) + (1000 * Ginv(mXXt))) %*% J %*% mY
optimal_q_hat
mXXt_dsmle = r_dsmle$K %*% t(r_dsmle$K)
mXXt_dsmle = r_dsmle$K
mXXt_dsmle
mXXt_ours = mX %*% t(mX)
mXXt_ours
mXXt_ours = mX_scaled %*% t(mX_scaled)
mXXt_ours
optimal_q_hat_dsmle = inv(diag(n) + (1000 * Ginv(mXXt_dsmle))) %*% J %*% mY
optimal_q_hat_dsmle
optimal_q_hat_ours = inv(diag(n) + (1000 * Ginv(mXXt))) %*% J %*% mY
optimal_q_hat_ours
optimal_q_hat_ours = inv(diag(n) + (1000 * Ginv(mXXt_ours))) %*% J %*% mY
optimal_q_hat_ours
inv(mX)
inv(mXXt)
mXXt = mX %*% t(mX)
inv(mXXt)
Ginv(mXXt)
mXXt_dsmle = r_dsmle$K
mXXt_ours = mX_scaled %*% t(mX_scaled)
D = diag(eigen(mXXt_ours)$values)
D
D^2
D = diag(eigen(mXXt_ours)$values)^-2
D
inv(D)
D = diag(eigen(mXXt_ours)$values)^-2
inv(D)
D = diag(eigen(mXXt_ours)$values)^(-2)
inv(D)
Ginv(D)
D = diag(eigen(mXXt_ours)$values)^(-2)
D
D = diag(eigen(mXXt_ours)$values)^2
D
D = diag(eigen(mXXt_ours)$values)^(-1)
D
D = diag(eigen(mXXt_ours)$values)^(-2)
D
mXXt_ours
diag(eigen(mXXt_ours)$values)
diag(eigen(mXXt_ours)$values, n)
eigen(mXXt_ours)$values
mXXt_ours * diag(n)
eigen(mXXt_ours)$values * diag(n)
(eigen(mXXt_ours)$values * diag(n))^-2
diag(n) + 1000* D
inv(diag(n) + 1000* D)
D = diag(eigen(mXXt_ours)$values-2)
D = diag(eigen(mXXt_ours)$values^-2)
(diag(n) + 1000* D)
inv(diag(n) + 1000* D)
U %*% inv(diag(n) + 1000* D) %*% t(U)
U %*% inv(diag(n) + 1000* D) %*% t(U) %*% J %*% mY
# executes kernel ridge regression
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
# define n, p
n = nrow(mX)
p = ncol(mX)
# initial XX^T, X^TX
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
# define J, using vector of 1s
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
D = diag(eigen(mXXt)$values^-2)
U = eigen(mXXt)$vectors
# find optimal intercept, and q
optimal_mBeta_zero = (1/n) * v_1 %*% mY
# use moore-penrose inverse here
#optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% J %*% mY
optimal_q_hat = U %*% inv(diag(n) + 1000* D) %*% t(U) %*% J %*% mY
# from q's, get other beta's
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
# define beta's together
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
# find predicted values, sums of squared errors
yhat = cbind(1,mX) %*% mBeta_Intercept
SSE = sum((mY - yhat)^2)
# return results as list
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
# but our sse is much lower...different predicted values, most likely due to different beta's
r_ours = kernel_ridge(mX_scaled, mY, lambda=1000)
r_ours$SSE
r_ours$Beta
r_ours$SSE
sum((r_dsmle$y - r_dsmle$yhat)^2)
r_ours$yhat - r_dsmle$yhat
View(Airline)
r_ours$yhat
View(Airline)
# observe here that the two kernels are the same!
mXXt_dsmle = r_dsmle$K
mXXt_ours = mX_scaled %*% t(mX_scaled)
mXXt_dsmle
mXXt_ours
mXXt_dsmle==mXXt_ours
mXXt_dsmle
mXXt_ours
mXXt_dsmle-mXXt_ours
crossprod(mX_scaled, t(mX_scaled))
help(crossprod)
tcrossprod(mX_scaled, t(mX_scaled))
crossprod(mX_scaled, t(mX_scaled))
crossprod(t(mX_scaled), mX_scaled)
# executes kernel ridge regression
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
# define n, p
n = nrow(mX)
p = ncol(mX)
# initial XX^T, X^TX
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
# define J, using vector of 1s
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
D = diag(eigen(mXXt)$values^-2)
U = eigen(mXXt)$vectors
# find optimal intercept, and q
optimal_mBeta_zero = (1/n) * v_1 %*% mY
# use moore-penrose inverse here
#optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% J %*% mY
optimal_q_hat = U %*% inv(diag(n) + 1000* D) %*% t(U) %*% J %*% mY
# from q's, get other beta's
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
# define beta's together
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
# find predicted values, sums of squared errors
yhat = cbind(1,mXXt) %*% mBeta_Intercept
SSE = sum((mY - yhat)^2)
# return results as list
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
# but our sse is much lower...different predicted values, most likely due to different beta's
r_ours = kernel_ridge(mX_scaled, mY, lambda=1000)
r_ours$Beta
r_ours$SSE
# executes kernel ridge regression
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
# define n, p
n = nrow(mX)
p = ncol(mX)
# initial XX^T, X^TX
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
# define J, using vector of 1s
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
D = diag(eigen(mXXt)$values^-2)
U = eigen(mXXt)$vectors
# find optimal intercept, and q
optimal_mBeta_zero = (1/n) * v_1 %*% mY
# use moore-penrose inverse here
#optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% J %*% mY
optimal_q_hat = U %*% inv(diag(n) + 1000* D) %*% t(U) %*% J %*% mY
# from q's, get other beta's
beta_from_q_hat = inv(mXtX) %*% t(mX) %*% optimal_q_hat
# define beta's together
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
# find predicted values, sums of squared errors
yhat = cbind(1,mXXt) %*% mBeta_Intercept
SSE = sum((mY - yhat)^2)
# return results as list
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
# but our sse is much lower...different predicted values, most likely due to different beta's
r_ours = kernel_ridge(mX_scaled, mY, lambda=1000)
# executes kernel ridge regression
kernel_ridge <- function(mX, mY, lambda, type_kernel = "Linear"){
# define n, p
n = nrow(mX)
p = ncol(mX)
# initial XX^T, X^TX
mXXt = mX %*% t(mX)
mXtX = t(mX) %*% mX
# define J, using vector of 1s
v_1 =  matrix(1, 1, 90)
J = diag(n)- ((1/n)*  t(v_1) %*% v_1)[[1]]
D = diag(eigen(mXXt)$values^-2)
U = eigen(mXXt)$vectors
# find optimal intercept, and q
optimal_mBeta_zero = (1/n) * v_1 %*% mY
# use moore-penrose inverse here
#optimal_q_hat = inv(diag(n) + (lambda * Ginv(mXXt))) %*% J %*% mY
optimal_q_hat = U %*% inv(diag(n) + 1000* D) %*% t(U) %*% J %*% mY
# from q's, get other beta's
beta_from_q_hat = inv(mXtX) %*% t(mXXt) %*% optimal_q_hat
# define beta's together
mBeta_Intercept = rbind(optimal_mBeta_zero, beta_from_q_hat)
# find predicted values, sums of squared errors
yhat = cbind(mXXt) %*% mBeta_Intercept
SSE = sum((mY - yhat)^2)
# return results as list
result = list(Beta = mBeta_Intercept,
yhat = yhat,
SSE = SSE,
K = mXXt
)
return(result)
}
# but our sse is much lower...different predicted values, most likely due to different beta's
r_ours = kernel_ridge(mX_scaled, mY, lambda=1000)
